---
title: What are Commands?
description: An introduction to commands, the building block of Ivy.
navigation:
  icon: i-lucide-command
---

::note
This page took inspiration from the
[WPILib commands documentation](https://docs.wpilib.org/en/stable/docs/software/commandbased/what-is-command-based.html).
::

Ivy is a library that implements the **command-based programming paradigm**.
While it is not the only way to write robot code, command-based robot code is
clean, extensible, reusable, and modular. Command-based programming is also
a type of declarative programming, which means that you write code
describing _what_ you want your robot to do, instead of specifying _how_ to do
it.

The building block of command-based programming is, of course, the
**command**. A command represents an action the robot can perform. Commands
are run by the **command scheduler**, which runs scheduled commands at the
appropriate times. One of the biggest benefits of commands is that they can
run in parallel with each other. This is done using **cooperative
multitasking**. This means that each command must give up control of the
thread periodically to allow other commands to run, which allows all
commands to run on a single thread.

To run commands in parallel, the
scheduler runs each command for a short period of time and then runs the
next command, running each scheduled command once per loop. For example, if
the scheduler was running command A and command B in parallel, it would run
a tiny bit of command A, a tiny bit of command B, then a tiny bit of
command A again, and so on.

Commands have **four core parts**:

- `start()`: Called immediately when the command is scheduled to run.
- `execute()`: Called every loop by the scheduler. This is where the command
  performs a tiny bit of its action.
- `done()`: Returns whether the command finished or should continue running
  next loop.
- `end(endCondition)`: Called when the command finishes, is
  interrupted, or is suspended (more on that later).

Let's take a look at an example command that raises an arm using a PID
controller and cuts power to the motors when the arm reaches the target
position. Since we don't know how to create commands yet, we'll just
consider what each part of the command would do.

- `start()`: Does nothing.
- `execute()`: Uses the PID controller to set the arm motor's power.
- `done()` Returns whether the arm is within tolerance of the target position.
- `end()`: Sets the arm motor's power to zero.

## Requirements and priorities

In the above example, with the arm raising command, you would likely also have a command
that lowers the arm. When raising the arm, there are numerous different ways that you may
want to schedule the lowering command. In some situations, you may want to lower the arm
immediately, overriding the raising command. In others, you may want to wait until the raising
command finishes before lowering the arm, but you may decide this after you scheduled the raising
command (meaning you can't use a sequential composition, as described in a later section).
You may also want to immediately lower the arm, but then immediately raise it again.

With the tools provided so far, it would be inconvenient and verbose to have to write a
separate command for each of these scenarios. To solve this problem, Ivy provides
**requirements**. Requirements are a way to specify that a given command uses certain objects
or subsystems on your robot. In the above example, you would have the raising and lowering commands
require the arm motor(s) or the arm subsystem if you've created a class.

By themselves, requirements are not very useful. However, when combined with priorities,
they allow you to specify how commands that share requirements (meaning they operate on
the same part of the robot) should interact. A priority is an integer that specifies
how important a command is. The default priority is 0.

When you try to schedule a command with conflicting requirements with any currently scheduled
commands, there are three types of behaviors that can occur:

- **Interrupted Behavior**: If all currently scheduled commands have a lower priority than the new,
  conflicting command, this determines what happens to each currently scheduled command.
  `InterruptedBehavior` is an enum with types `END` and `SUSPEND`. `END` means that each
  currently scheduled command will terminate and not be run again, while `SUSPEND` means
  that the currently scheduled command will be suspended and continue when the conflicting
  command finishes. In both cases, end(true) will be called on each currently scheduled command.
  Defaults to `END`.
- **Blocked Behavior**: If any currently scheduled command has a higher priority than the new,
  conflicting command, this determines what happens to the conflicting command. `BlockedBehavior`
  is an enum with types `CANCEL` and `QUEUE`. `CANCEL` means that the conflicting command will be
  canceled, while `QUEUE` means that the conflicting command will be queued and run after the currently
  scheduled conflicting commands finish.
  Defaults to `CANCEL`.
- **Conflict Behavior**: If the highest priority of all currently scheduled commands is equal to
  the new conflicting command, this determines what happens to the new conflicting command.
  `ConflictBehavior` is an enum with types `CANCEL`, `QUEUE`, and `OVERRIDE`. `CANCEL` means that
  the new conflicting command will not be scheduled, `QUEUE` means that the new conflicting command will
  be queued and run after the currently scheduled conflicting commands finish, and `OVERRIDE` means that
  the new conflicting command will interrupt the currently scheduled conflicting commands and run instead
  (note, this triggers the `InterruptedBehavior` of the currently scheduled conflicting commands).
  Defaults to `OVERRIDE`.

Returning to our arm example, instead of creating separate commands for each of the scenarios,
we can create a single command and modify it's priority to handle each scenario.

Note that requirements are a completely optional feature, and you can use Ivy perfectly well
without them. However, they are a powerful tool that can help you write simpler and safer code
should you want to use them.
